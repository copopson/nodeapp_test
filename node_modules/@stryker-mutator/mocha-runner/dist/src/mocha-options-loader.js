"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MochaOptionsLoader = exports.DEFAULT_MOCHA_OPTIONS = void 0;
const tslib_1 = require("tslib");
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const lib_wrapper_1 = require("./lib-wrapper");
const utils_1 = require("./utils");
/**
 * Subset of defaults for mocha options
 * @see https://github.com/mochajs/mocha/blob/master/lib/mocharc.json
 */
exports.DEFAULT_MOCHA_OPTIONS = Object.freeze({
    extension: ['js'],
    require: [],
    file: [],
    ignore: [],
    opts: './test/mocha.opts',
    spec: ['test'],
    ui: 'bdd',
    'no-package': false,
    'no-opts': false,
    'no-config': false,
    'async-only': false,
});
class MochaOptionsLoader {
    constructor(log) {
        this.log = log;
    }
    load(strykerOptions) {
        const mochaOptions = { ...strykerOptions.mochaOptions };
        const options = { ...exports.DEFAULT_MOCHA_OPTIONS, ...this.loadMochaOptions(mochaOptions), ...mochaOptions };
        if (this.log.isDebugEnabled()) {
            this.log.debug(`Loaded options: ${JSON.stringify(options, null, 2)}`);
        }
        return options;
    }
    loadMochaOptions(overrides) {
        if (lib_wrapper_1.LibWrapper.loadOptions) {
            this.log.debug("Mocha >= 6 detected. Using mocha's `%s` to load mocha options", lib_wrapper_1.LibWrapper.loadOptions.name);
            return this.loadMocha6Options(overrides);
        }
        else {
            this.log.warn('DEPRECATED: Mocha < 6 detected. Please upgrade to at least Mocha version 6. Stryker will drop support for Mocha < 6 in V5.');
            this.log.debug('Mocha < 6 detected. Using custom logic to parse mocha options');
            return this.loadLegacyMochaOptsFile(overrides);
        }
    }
    loadMocha6Options(overrides) {
        var _a;
        const args = (0, utils_1.serializeMochaLoadOptionsArguments)(overrides);
        const rawConfig = (_a = lib_wrapper_1.LibWrapper.loadOptions(args)) !== null && _a !== void 0 ? _a : {};
        if (this.log.isTraceEnabled()) {
            this.log.trace(`Mocha: ${lib_wrapper_1.LibWrapper.loadOptions.name}([${args.map((arg) => `'${arg}'`).join(',')}]) => ${JSON.stringify(rawConfig)}`);
        }
        const options = (0, utils_1.filterConfig)(rawConfig);
        return options;
    }
    loadLegacyMochaOptsFile(options) {
        if (options['no-opts']) {
            this.log.debug('Not reading additional mochaOpts from a file');
            return options;
        }
        switch (typeof options.opts) {
            case 'undefined':
                const defaultMochaOptsFileName = path_1.default.resolve(exports.DEFAULT_MOCHA_OPTIONS.opts);
                if (fs_1.default.existsSync(defaultMochaOptsFileName)) {
                    return this.readMochaOptsFile(defaultMochaOptsFileName);
                }
                else {
                    this.log.debug('No mocha opts file found, not loading additional mocha options (%s was not defined).', util_1.PropertyPathBuilder.create().prop('mochaOptions').prop('opts').build());
                    return {};
                }
            case 'string':
                const optsFileName = path_1.default.resolve(options.opts);
                if (fs_1.default.existsSync(optsFileName)) {
                    return this.readMochaOptsFile(optsFileName);
                }
                else {
                    this.log.error(`Could not load opts from "${optsFileName}". Please make sure opts file exists.`);
                    return {};
                }
            default:
                return {};
        }
    }
    readMochaOptsFile(optsFileName) {
        this.log.info(`Loading mochaOpts from "${optsFileName}"`);
        return this.parseOptsFile(fs_1.default.readFileSync(optsFileName, 'utf8'));
    }
    parseOptsFile(optsFileContent) {
        const options = optsFileContent.split('\n').map((val) => val.trim());
        const mochaRunnerOptions = Object.create(null);
        options.forEach((option) => {
            var _a;
            const args = option.split(' ').filter(Boolean);
            if (args[0]) {
                switch (args[0]) {
                    case '--require':
                    case '-r':
                        args.shift();
                        if (!mochaRunnerOptions.require) {
                            mochaRunnerOptions.require = [];
                        }
                        mochaRunnerOptions.require.push(...args);
                        break;
                    case '--async-only':
                    case '-A':
                        mochaRunnerOptions['async-only'] = true;
                        break;
                    case '--ui':
                    case '-u':
                        mochaRunnerOptions.ui = (_a = this.parseNextString(args)) !== null && _a !== void 0 ? _a : exports.DEFAULT_MOCHA_OPTIONS.ui;
                        break;
                    case '--grep':
                    case '-g':
                        let arg = `${this.parseNextString(args)}`;
                        if (arg.startsWith('/') && arg.endsWith('/')) {
                            arg = arg.substring(1, arg.length - 1);
                        }
                        mochaRunnerOptions.grep = arg;
                        break;
                    default:
                        this.log.debug(`Ignoring option "${args[0]}" as it is not supported.`);
                        break;
                }
            }
        });
        return mochaRunnerOptions;
    }
    parseNextString(args) {
        if (args.length > 1) {
            return args[1];
        }
        else {
            return undefined;
        }
    }
}
exports.MochaOptionsLoader = MochaOptionsLoader;
MochaOptionsLoader.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger);
//# sourceMappingURL=mocha-options-loader.js.map