"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MochaTestRunner = void 0;
const tslib_1 = require("tslib");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const stryker_mocha_reporter_1 = require("./stryker-mocha-reporter");
const pluginTokens = (0, tslib_1.__importStar)(require("./plugin-tokens"));
class MochaTestRunner {
    constructor(log, options, loader, mochaAdapter, requireCache, globalNamespace) {
        var _a;
        this.log = log;
        this.options = options;
        this.loader = loader;
        this.mochaAdapter = mochaAdapter;
        this.requireCache = requireCache;
        stryker_mocha_reporter_1.StrykerMochaReporter.log = log;
        this.instrumenterContext = (_a = global[globalNamespace]) !== null && _a !== void 0 ? _a : (global[globalNamespace] = {});
    }
    async init() {
        this.mochaOptions = this.loader.load(this.options);
        this.testFileNames = this.mochaAdapter.collectFiles(this.mochaOptions);
        if (this.mochaOptions.require) {
            if (this.mochaOptions.require.includes('esm')) {
                throw new Error('Config option "mochaOptions.require" does not support "esm", please use `"testRunnerNodeArgs": ["--require", "esm"]` instead. See https://github.com/stryker-mutator/stryker-js/issues/3014 for more information.');
            }
            this.rootHooks = await this.mochaAdapter.handleRequires(this.mochaOptions.require);
        }
    }
    async dryRun({ coverageAnalysis, disableBail }) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        let interceptor = () => { };
        if (coverageAnalysis === 'perTest') {
            interceptor = (mocha) => {
                const self = this;
                mocha.suite.beforeEach('StrykerIntercept', function () {
                    var _a;
                    self.instrumenterContext.currentTestId = (_a = this.currentTest) === null || _a === void 0 ? void 0 : _a.fullTitle();
                });
            };
        }
        const runResult = await this.run(interceptor, disableBail);
        if (runResult.status === test_runner_1.DryRunStatus.Complete && coverageAnalysis !== 'off') {
            runResult.mutantCoverage = this.instrumenterContext.mutantCoverage;
        }
        return runResult;
    }
    async mutantRun({ activeMutant, testFilter, disableBail }) {
        this.instrumenterContext.activeMutant = activeMutant.id;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        let intercept = () => { };
        if (testFilter) {
            const metaRegExp = testFilter.map((testId) => `(${(0, util_1.escapeRegExp)(testId)})`).join('|');
            const regex = new RegExp(metaRegExp);
            intercept = (mocha) => {
                mocha.grep(regex);
            };
        }
        const dryRunResult = await this.run(intercept, disableBail);
        return (0, test_runner_1.toMutantRunResult)(dryRunResult, true);
    }
    async run(intercept, disableBail) {
        this.requireCache.clear();
        const mocha = this.mochaAdapter.create({
            reporter: stryker_mocha_reporter_1.StrykerMochaReporter,
            bail: !disableBail,
            timeout: false,
            rootHooks: this.rootHooks,
        });
        this.configure(mocha);
        intercept(mocha);
        this.addFiles(mocha);
        try {
            await this.runMocha(mocha);
            // Call `requireCache.record` before `mocha.dispose`.
            // `Mocha.dispose` already deletes test files from require cache, but its important that they are recorded before that.
            this.requireCache.record();
            if (mocha.dispose) {
                // Since mocha 7.2
                mocha.dispose();
            }
            const reporter = stryker_mocha_reporter_1.StrykerMochaReporter.currentInstance;
            if (reporter) {
                const result = {
                    status: test_runner_1.DryRunStatus.Complete,
                    tests: reporter.tests,
                };
                return result;
            }
            else {
                const errorMessage = `Mocha didn't instantiate the ${stryker_mocha_reporter_1.StrykerMochaReporter.name} correctly. Test result cannot be reported.`;
                this.log.error(errorMessage);
                return {
                    status: test_runner_1.DryRunStatus.Error,
                    errorMessage,
                };
            }
        }
        catch (errorMessage) {
            return {
                errorMessage,
                status: test_runner_1.DryRunStatus.Error,
            };
        }
    }
    runMocha(mocha) {
        return new Promise((res) => {
            mocha.run(() => res());
        });
    }
    addFiles(mocha) {
        var _a;
        (_a = this.testFileNames) === null || _a === void 0 ? void 0 : _a.forEach((fileName) => {
            mocha.addFile(fileName);
        });
    }
    configure(mocha) {
        const options = this.mochaOptions;
        function setIfDefined(value, operation) {
            if (typeof value !== 'undefined') {
                operation.apply(mocha, [value]);
            }
        }
        setIfDefined(options['async-only'], (asyncOnly) => asyncOnly && mocha.asyncOnly());
        setIfDefined(options.ui, mocha.ui);
        setIfDefined(options.grep, mocha.grep);
    }
}
exports.MochaTestRunner = MochaTestRunner;
MochaTestRunner.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, pluginTokens.loader, pluginTokens.mochaAdapter, pluginTokens.directoryRequireCache, pluginTokens.globalNamespace);
//# sourceMappingURL=mocha-test-runner.js.map